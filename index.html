<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>OpenTok Elm Demo</title>
</head>
<body>
<div id="main"></div>

<script src="compiled/app.js"></script>
<script src="https://static.opentok.com/v2/js/opentok.js"></script>
<script src="config.js"></script>
<script>
(() => {
  OT.setLogLevel(OT.DEBUG);

  const node = document.getElementById('main');
  const app = window.Elm.App.embed(node, {
    credentials: window.appCredentials
  });
  const sessions = {};

  app.ports.connect.subscribe(credentials => {
    const { apiKey, sessionId, token } = credentials;

    if (sessions[sessionId]) {
      app.ports.connectCallback.send({
        sessionId,
        success: false,
        message: `Already called connect once on session with ID: ${sessionId}`
      });
      return;
    }

    const session = OT.initSession(apiKey, sessionId);
    const streams = {};
    sessions[sessionId] = { session, streams, subscribers: {} };

    const streamCreated = event => {
      const { stream } = event;
      const { streamId } = stream;
      streams[streamId] = stream;
      app.ports.onStreamCreated.send({ sessionId, streamId });
    };

    const streamDestroyed = event => {
      const { streamId } = event.stream;
      delete streams[streamId];
      app.ports.onStreamDestroyed.send({ sessionId, streamId });
    };

    const eventHandlers = { streamCreated, streamDestroyed };
    session.on(eventHandlers);
    sessions[sessionId].eventHandlers = eventHandlers;

    session.connect(token, err => {
      const success = !Boolean(err);
      const message = err ? String(err.message) : '';
      app.ports.connectCallback.send({ sessionId, success, message });
    });
  });

  app.ports.disconnect.subscribe(options => {
    const { sessionId } = options;

    if (sessions[sessionId]) {
      const { session, subscribers, publisher, eventHandlers } = sessions[sessionId];
      session.off(eventHandlers);
      Object.keys(subscribers).forEach(streamId => {
        session.unsubscribe(subscribers[streamId]);
      });
      session.unpublish(publisher);
      session.disconnect();
      session.destroy();
      delete sessions[sessionId];
    }
  });

  app.ports.publish.subscribe(options => {
    const { sessionId, containerId } = options;
    let properties = {}; // FIXME

    if (!sessions[sessionId]) {
      app.ports.publishCallback.send({
        sessionId,
        success: false,
        message: `Could not publish to unknown session with ID: ${sessionId}`
      });
      return;
    }

    const { session } = sessions[sessionId];

    properties = Object.assign({}, properties || {}, {insertMode: 'append'});

    const container = document.createElement('div');
    const publisher = session.publish(container, properties, err => {
      const success = !Boolean(err);
      const message = err ? String(err.message) : '';
      const streamId = success ? publisher.stream.streamId : '';
      app.ports.publishCallback.send({ sessionId, streamId, success, message });
    });
    const appendContainer = () => {
      const el = document.getElementById(containerId);
      if (el) {
        el.appendChild(container);
      } else {
        setTimeout(appendContainer, 100);
      }
    };
    publisher.once('videoElementCreated', appendContainer);
    sessions[sessionId].publisher = publisher;
  });

  app.ports.subscribe.subscribe(options => {
    const { sessionId, streamId, containerId } = options;
    let properties = {}; // FIXME

    if (!sessions[sessionId]) {
      app.ports.subscribeCallback.send({
        sessionId,
        streamId,
        success: false,
        message: `Could not subscribe to unknown session with ID: ${sessionId}`
      });
      return;
    }

    const { session, streams, subscribers } = sessions[sessionId];

    const stream = streams[streamId];
    if (!stream) {
      app.ports.subscribeCallback.send({
        sessionId,
        streamId,
        success: false,
        message: `Could not subscribe to unknown stream with ID: ${streamId}`
      });
      return;
    }

    properties = Object.assign({}, properties || {}, {insertMode: 'append'});

    const container = document.createElement('div');
    const subscriber = session.subscribe(stream, container, properties, err => {
      const success = !Boolean(err);
      const message = err ? String(err.message) : '';
      app.ports.subscribeCallback.send({ sessionId, streamId, success, message });
    });
    const appendContainer = () => {
      const el = document.getElementById(containerId);
      if (el) {
        el.appendChild(container);
      } else {
        setTimeout(appendContainer, 100);
      }
    };
    subscriber.once('videoElementCreated', appendContainer);
    subscribers[streamId] = subscriber;
  });

  app.ports.unsubscribe.subscribe(options => {
    const { sessionId, streamId } = options;

    if (!sessions[sessionId]) {
      return;
    }

    const { session, subscribers } = sessions[sessionId];

    if (!subscribers[streamId]) {
      return;
    }

    session.unsubscribe(subscribers[streamId]);
  });
})();
</script>

</body>
</html>
